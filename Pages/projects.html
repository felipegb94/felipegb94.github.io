
    <!-- Page Content -->
    <div id="projects-content">

        <div class="row">
            <div class="col-sm-8" id="content">
                <div id="TableContents" class="row project">
                    <h3>Index</h3>

                    <div class="col-sm-4 ToC-div">
                        <h4>Physics-based modeling</h4>
                        <ul>
                            <li><a href="#CharmSPH">CharmSPH</a></li>
                            <li><a href="#SPHSim2D">SPHSim2D</a></li>
                        </ul>
                    </div>
                    <div class="col-sm-4 ToC-div">
                        <h4>Permutation Testing</h4>
                        <ul>
                            <li><a href="#RapidPT">RapidPT</a></li>
                            <li><a href="#CompletePT">CompletePT</a></li>
                        </ul>
                    </div>
                    <div class="col-sm-4 ToC-div">
                        <h4>Web Applications</h4>
                        <ul>
                            <li><a href="#MetricsDB">Metrics Database for Project Chrono</a></li>
                            <li><a href="#PointCloudWebUtils">PointCloudWebUtils</a></li>
                        </ul>
                    </div>
                    <div class="col-sm-4 ToC-div">
                        <h4>Parallel Programming</h4>
                        <ul>
                            <li><a href="#HPCPrototyping">HPC Prototyping</a></li>
                            <li><a href="#piCalc">Macros-based hybrid OpenMP and CUDA implementation</a></li>
                        </ul>
                    </div>
                    <div class="col-sm-4 ToC-div">
                        <h4>Other</h4>
                        <ul>
                            <li><a href="#EvalMeshToPC">Evalutation of Mesh To Point Cloud Approaches</a></li>
                        </ul>
                    </div>
                </div>
                <div id="CharmSPH" class="row project">
                    <h3>CharmSPH</h3>
                    <hr>
                    <div class="col-sm-8 project-description">
                        <strong>Github:</strong> Currently a private project.</br>
                        <strong>Poster:</strong> <a href="Presentations/CharmSPH_MaGIC.pdf" target="_blank"> CharmSPH </a>- Presented during the 2015 Machine-Ground Interaction Consortium.</a></br>
                        <p>
                            <strong>Description:</strong> CharmSPH is a distributed memory smoothed particle hydrodynamics (SPH) engine implemented using the <a href="http://charmplusplus.org" target="_blank">Charm++ programming framework</a>. 
                        </p>
                    </div>
                    <div class="col-sm-4 project-image">
                        <img src="images/hybrid_decomposition.jpg"  class="img-thumbnail">
                    </div>

                </div>
                <div id="RapidPT" class="row project">
                    <h3>Rapid Permutation Testing</h3>
                    <hr>
                    <div class="col-sm-8 project-description">
                        <strong>Github:</strong> <a href="http://github.com/felipegb94/RapidPermTest" target="_blank">RapidPT</a>
                        <p>
                            <strong>Description:</strong> RapidPT is the result of a collaborative effort of improving the scalability, validating, benchmarking, extending, and open-sourcing the novel permutation testing algorithm that reformulates the problem into a matrix completion one. This algorithm is presented in the NIPS 2013 paper, "Speeding up Permutation Testing in Neuroimaging", and can be found<a href="http://pages.cs.wisc.edu/~vamsi/pt_fast.html" target="_blank"> here</a>.
                        </p>
                    </div>
                    <div class="col-sm-4 project-image">
                        <img src="images/maxnull_rapidpt_vs_snpm.jpg" class="img-thumbnail">
                    </div>


                </div>
                <div id="CompletePT" class="row project">
                    <h3>Complete Permutation Testing</h3>
                    <hr>
                    <div class="col-sm-12 project-description">
                        <strong>Github:</strong> <a href="https://github.com/felipegb94/CompletePermTesting" target="_blank">CompletePT</a>
                        <p>
                            <strong>Description:</strong> CompletePT is a repository that contains CPU and GPU implementations of the permutation testing algorithm using one-sample and two-sample t-test. The programs have been validated against the library SnPM and are currently being using for timing and accuracy comparissons with RapidPT and SnPM. The CPU implementation relies on the linear algebra library, Armadillo. The GPU implementation currently relies on ArrayFire for the computation part but uses Armadillo for some I/O.
                        </p>
                        <p>
                            Future goals: Make the GPU version solely depend on ArrayFire and see if  the ArrayFire community is interested in adding it to its statistics library.
                        </p>
                    </div>
                </div>
                <div id="SPHSim2D" class="row project">
                    <h3>SPHSim2D</h3>
                    <hr>
                    <div class="col-sm-8 project-description">
                        <strong>Github:</strong> <a href="https://github.com/uwsbel/SPHSim2D" target="_blank"> SPHSim2D</a>
                        <p>
                            <strong>Description:</strong> SPHSim2D is a 2D fluid simulation program based on the Smoothed Particle Hydrodynamics (SPH) technique. The main purpose of this code is to act as a prototyping environment of boundary conditions, integration schemes and techniques to improve the simulation stability. The three basic features of the program are: fast neighbor search, leap-frog time integration, and the use of static SPH markers as wall boundaries. The ultimate goal is that as more and more SPH features are prototyped in this environment the code will evolve into a mature SPH code.
                        </p>
                        <ul>
                            <li>
                                The code is currently being used to: investigate an implicit time integration scheme.
                            </li> 
                            <li>
                                Future features: A generalized wall boundary condition, periodic boundary condition, some validation model (poiseille flow or coutte flow), density reinitialization, XSPH.
                            </li>
                        </ul>
                    </div>
                    <div class="col-sm-4 project-image">
                        <img src="images/sph_discretization.jpg" class="img-thumbnail">
                    </div>

                </div>

                <div id="MetricsDB" class="row project">
                    <h3>Metrics Database for Project Chrono</h3>
                    <hr>
                    <div class="col-sm-12 project-description">
                        <strong>Github:</strong> <a href="https://github.com/uwsbel/metrics-database" target="_blank">Metrics Database</a>
                        <p>
                            <strong>Description: </strong>This project was developed to record output metrics (mostly performance) of the tests that are run on the open source multi-physics engine, <a href="https://github.com/projectchrono/chrono" target="_blank">Chrono</a>, and be able to query these metrics and display on a web application. In order to meet this goal I developed five pieces of code that together fully automated the process of tracking these metrics, and a sixth component that will hopefully be implemented in the future. 
                            <ol>
                                <li>
                                    <strong><a href="https://github.com/felipegb94/BaseTest" target="_blank">BaseTest:</a> </strong>First I developed a BaseTest class from which all tests that wish to report metrics are derived from. This allowed the test developers to easily report the metrics by just calling a simple function called addMetric(...). The class would then output the metrics in a JSON format. 
                                </li> 
                                <li>
                                    <strong>Parser: </strong>The second part of the program was the parser. Whenever a push is made to Chrono there is an automated build system (buildbot based) that runs a bunch of tests, some of which are derived from BaseTest. After all the tests are ran a lot of JSON files have been generated, and builbot calls a parsing script which parses each file and adds them to a PostgreSQL database through an API call.
                                </li> 
                                <li>
                                    <strong>Metrics Database API: </strong>Any kind of request made to the relational database had to be done through a Flask-based API. This allowed easily handle things like reading and writing to the database, and authentication.
                                </li> 
                                <li>
                                    <strong>Database: </strong>A PostgreSQL database was used. The database was created and updated using a python package called SQLAlchemy. 
                                </li> 
                                <li>
                                    <strong>Frontend: </strong>The frontend allows Chrono developers to visualize the time evolution of the metrics. This is interesting for performance metrics since you can see how certain parts of Chrono improve (or get worse) in performance as modifications are made. But it can also be used to monitor that the accuracy of certain benchmark simulations stays over a threshold.
                                </li> 
                                <li>
                                    <strong>Notification System (Not implemented): </strong> A notification system will hopefully be implemented in the future. The aim of this feature is to notify Chrono users of significant performance decrease after a push is made.
                                </li> 
                            </ol>
                        </p> 
                    </div>                   
                </div>
                <div id="PointCloudWebUtils"class="row project">
                    <h3>Point Cloud Web Utils</h3>
                    <hr>
                    <div class="col-sm-8 project-description">
                        <strong>Github:</strong> <a href="https://github.com/felipegb94/PointCloudWebUtils" target="_blank">PointCloudWebUtils</a></br>
                        <strong>Link:</strong> <a href="http://euler.wacc.wisc.edu/felipegb94/PointCloudWebUtils/" target="_blank">PointCloudWebUtils</a>. The link is currently broken due to server issues. This should be fixed soon.</br>

                        <p>
                            <strong>Description: </strong>PointCloudWebUtils are two WebGL/Three.js powered tools that I made to make the SPH model development easier for myself. 
                        </br></br>
                            The first one is a simple point cloud rendering tool that receives a csv file as an input and displays a color-coded point cloud where the colors represent the SPH marker type (fluid, boundary or solid). I  could also use Paraview or other visualizing tool but having to specify a bunch of options only to visualize the first time step to see if the initialization was done correctly is a couple minutes of work against a couple seconds in the web app.
                        </br></br>
                            The second one is the implementation of the ray crossing approach described in the Evaluation of Mesh To Point Cloud Alternatives report. I generates a point cloud from an input .obj file or from one of the premade meshes in three.js (cube, cylinder, torus, etc.). The figure on the right is the input mesh and the resulting point cloud of a humvee model.
                        </p> 
                    </div>   
                    <div class="col-sm-4 project-image">
                        <img src="images/MeshToPC_hmmvee.jpg" class="img-thumbnail">
                    </div>               
                </div>
                <div id="EvalMeshToPC"class="row project">
                    <h3>Evaluation of Mesh To Point Cloud Alternatives</h3>
                    <hr>
                    <div class="col-sm-8 project-description">

                        <strong>Github:</strong> <a href="http://github.com/felipegb94/" target="_blank">MeshToPC</a></br>

                        <strong>Technical Report (Incomplete):</strong> <a href="Papers/TR-MeshToPointCloudTool/TR-2015-10.pdf" target="_blank">MeshToPC TR</a>

                        <p>
                            <strong>Description: </strong>Together with two other members of SBEL we explored three alternatives to generate a point cloud from a mesh file (stl, obj, etc). The three approaches are briefly described <a href="Papers/TR-MeshToPointCloudTool/TR-2015-10.pdf" target="_blank">here</a>. The technical report is still incomplete and still needs some figures, corrections and updates.
                        </br></br>
                            <strong>Why? </strong>In FSI simulations that are based on a lagrangian representation of both the solid and the fluid (SPH) there is a need to have a point cloud representation of the solid. The point cloud that represents the solid are Boundary Condition Enforcing (BCE) markers which are essential to calculate the coupling forces [add citation]. For simple geometries creating a point cloud is relatively simple but for complex geometries it is not. Using modern CAD tools creating any kind of 3D geometry has become a trivial task, but all of these tools only export meshes and do not give the option to export a point cloud representation of the mesh. Therefore a mesh to point cloud converter tool is essential to develop a wide variety of FSI models.
                        </p> 
                    </div>   
                    <div class="col-sm-4 project-image">
                        <img src="images/PointCloud_PointPlaneProjectionResults.jpg" class="img-thumbnail">
                    </div>               
                </div>
                <div id="HPCPrototyping"class="row project">
                    <h3>HPC-Prototyping</h3>
                    <hr>
                    <div class="col-sm-12 project-description">

                        <strong>Github:</strong> <a href="https://github.com/felipegb94/HPC-Prototyping" target="_blank">High Performance Computing Prototyping</a>
                        </br>
                        <strong>Github:</strong> <a href="https://github.com/uwsbel/CharmPrototyping" target="_blank">CharmPrototyping</a>

                        <p>
                            <strong>Description: </strong>As a result of my work for the Blue Waters Student Internship Program and the Simulation-based Engineering Lab I have played around with some High-Performance Computing technologies. I add stuff to the HPC-Prototyping repository when trying a new language/tool so it contains code from all over the place. CharmPrototyping on the other hand only contains pieces of code related to Charm++ and setup documentation and script I wrote.
                        </p> 
                    </div>   
              
                </div>
                <div id="piCalc" class="row project">
                    <h3>Macros-based Hybrid CUDA and OpenMP Example Program</h3>
                    <hr>
                    <div class="col-sm-12 project-description">
                        <strong>Github:</strong> <a href="http://github.com/felipegb94/" target="_blank">pi-example</a>
                        <p>
                            <strong>Description: </strong>This is an example program that can easily switch between its OpenMP and CUDA implementations by changing some flags in the CMakeLists.txt file. The program calculates pi. Using a combination of macros and one of CUDA's newest features, unified memory, almost 100% of the code could be reused. Using macros a function can act as a regular function whose for loop is embedded in a OpenMP clause, or a CUDA kernel. If the program is compiled with CUDA and unified memory is available then the function/kernel call can be made by giving it a pointer to the memory allocated with cudaMallocManaged and the OpenMP and CUDA backend will be able to write to this memory without any problem. This can be seen in pi-kernel-unified.cu. This code was also used to see the performance of Multi-threading vs. GPU in one of the developer nodes of the cluster.   
                        </p>  
                    </div>                
                </div>   
            </div>
        </div>
    </div>
    <!-- /.container -->

