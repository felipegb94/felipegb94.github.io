% How to use:
% Your computer must know where to look for the cite.sty and graphics.sty libraries,
% as well as the plain.bst style file.  It should probably have these by default, but
% if you are getting errors then it is something to look into.
% In order to compile, run:
% latex templatefortechnicalreports
% bibtex templatefortechnicalreports
% latex templatefortechnicalreports
% latex templatefortechnicalreports
% If you have everything ready, this should produce a dvi which you can convert to ps or pdf.
% If you are having trouble with the alignment of graphics, try first converting dvi->ps then ps->pdf.

\documentclass[12pt]{article}
\usepackage{cite}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage[top=1.5in,bottom=1in,right=1in,left=1in]{geometry}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{textcomp}


\newenvironment{steps}[1]{
\begin{enumerate}[label=#1 \arabic*, align=left, leftmargin=2.0cm]}{
\end{enumerate}}
\makeatletter% http://tex.stackexchange.com/questions/29517/forcing-new-line-after-item-number-in-enumerate-environment/29518#29518
\def\step{%
   \@ifnextchar[ \@step{\@noitemargtrue\@step[\@itemlabel]}}
\def\@step[#1]{\item[#1]\mbox{}\\\hspace{\labelsep}}
\makeatother

\hypersetup{
  colorlinks, linkcolor=blue
}

\graphicspath{./figures}


\begin{document}

\begin{titlepage}

\begin{center}
\LARGE Technical Report 2015 \\
\vspace{1.0in} 
\Large Investigation of Mesh to Point Cloud Conversion Approaches for Applications in SPH-based Fluid-Solid Interaction Simulations\\
\vspace{2.0in}
\mdseries Felipe Gutierrez, Charles Ricchio, Milad Rakhsha, Arman Pazouki \\

\vfill

\today

\end{center}

\end{titlepage}
\newpage 

\begin{abstract}
Contact detection in SPH-based fluid dynamics engines can be efficiently done if a sorted neighbor list of each SPH marker is constructed. In fluid-solid interaction simulations an SPH marker can be one of three different types: fluid, boundary or solid. Solid SPH markers represent a solid body and can be think of as a point cloud representations of a 3D geometry. In real world applications the solid body geometries are often complex and generating a point cloud representation of them is a very challenging task. Computer Aided Design (CAD) tools, however, make it easy for a user to generate any kind of 3D mesh representation. Unfortunately, contact detection of SPH markers and 3D mesh is a highly inefficient process, therefore we want to be able to represent this mesh as a point cloud of solid markers. In this report, we present three different approaches to convert a 3D mesh, generated using a CAD tool, into a point cloud representation of the mesh. Finally, we run the same simulation multiple times with a point cloud generated with each approach and analyze which approach produces the most stable simulations.

Keywords: Graphics, Mesh, Point Cloud, Smoothed Particle Hydrodynamics, SPH
\end{abstract}
\newpage 

\tableofcontents
\newpage

\section{Introduction}
\label{sec:introduction}
Background goes here:
Possible stuff to introduce here: 

\section{Ray Crossing Approach}\
\label{sec:raycrossingapproach}
In this section we are going to present and explain the essential code snippets that allow 

\subsection{Algorithm Overview}
\label{subsec:algorithmoverview}
The algorithm presented in this section to generate a point cloud from an input mesh relies on answering one simple question repeatedly: Is the current point inside the mesh, or not? In order to determine if a point is inside, an approach known in the literature as: even-odd rule, the crossing number method and ray-crossing method was used \cite{wiki, Sunday2012}. The algorithm goes as follow; a ray is cast in any direction from the point to infinity, then the number of intersection of that ray with the mesh is counted, if the number of intersections is odd then the point is inside the mesh, otherwise it is outside the mesh. An visualization of this technique can be seen in Figure \ref{fig:crossingnumberfigure}.

\begin{figure}[htp]
\centering
	\includegraphics[scale=0.5]{figures/figure1_CrossingNumber.png}
	\caption{Crossing Number Example. On both the left and the right example we can see that the number of ray intersections from points inside the blue meshes is odd.}
	\label{fig:crossingnumberfigure}
\end{figure}

\subsection{Implementation}
\label{subsec:implementation}
The algorithm was implemented as a web application in Javascript using a lightweight 3D library called Three.js \cite{Three2015}. The workflow of the web application goes as follows:
\begin{steps}{Action}
\step Import the mesh. This can be done in two different ways: Use one of the pre-made meshes provided by Three.js or import a custom mesh defined in an .obj file format. 
\step Scale the mesh to the needed dimensions of the application.
\step Compute a bounding box surrounding the mesh. This allows us to only iterate through points that are either inside or that are closely surrounding the mesh.
\step Define the spacing between points. In SPH simulations this would be what is usually called h. 
\step Iterate through the points inside the bounding box separated from each other at a distance which was specified in step 4. At each point cast 3 rays: one pointing to the center, another one pointing close to the center and a third one pointing to one of the bounding box corners. If the number of intersects with the mesh of all rays is odd, then the point is inside the mesh.
\end{steps}

Casting only one ray per point in any direction theoretically should be enough to give us all points inside the mesh. However, the ray casting tool provided by Three.js sometimes makes mistakes and includes a few points outside the mesh. The reason for this might be that: the ray is going exactly through where a point defining a vertex is located, or the point casting the ray is located exactly on a triangle of the mesh, or the casted ray is tangent to a vertex of the mesh. In order to remove these noisy points, 3 different rays are cast in different directions.

\subsection{Tool Usage}
\label{subsec:toolusage}
The mesh to point cloud tool web application is available at \url{http://euler.wacc.wisc.edu/felipegb94/PointCloudWebUtils/}. This can only be accessed if the user is connected to the UW-Madison network. There is no user interface yet, but all of the functionality is currently there. Therefore to use it you will have to edit a few files in Euler at \textit{/home/felipegb94/public\_html/PointCloudWebUtils}.

To create a point cloud from a pre-made Three.js meshes you have to:
\begin{steps}{Action}
\step Open \textit{MeshToPointCloud.html}
\step Go to line 114
\step Edit the line that says: RenderThreeMesh(“Cylinder”);
\step Change Cylinder for any of the following pre-made meshes available: “Cube”, “Sphere”, “Cylinder”, “Cone”, “Torus”, “SemiTorus”, “TorusKnot”.
\step Go to\url{http://euler.wacc.wisc.edu/~felipegb94/PointCloudWebUtils/} and click on GeneratePC and then on Threejs mesh to PC.
\end{steps}

To create a point cloud from a custom mesh defined in an .obj file you have to:
\begin{steps}{Action}
\step Copy the .obj file to Euler inside the folder: \textit{/home/felipegb94/public\_html/PointCloudWebUtils/meshes/}.
\step Open \textit{MeshFileToPointCloud.html}
\step Go to line 114
\step Edit the line that says: \textit{RenderMesh("meshes/humvee.obj")};
\step Change \textit{“meshes/humvee.obj”} to \textit{“meshes/nameOfYourMesh.obj”}
\step Go to \url{http://euler.wacc.wisc.edu/~felipegb94/PointCloudWebUtils/} and click on GeneratePC and then on Mesh File to PC.
\end{steps}

To edit the point spacing you have to:
\begin{steps}{Action}
\step Open \textit{js/ThreeUtils.js}
\step In the function MeshToPC(MeshGeometry, MeshObject), look for the definition of dr, set it to the spacing you want.
\end{steps}

To edit the scale of the point cloud of a custom mesh you have to:
\begin{steps}{Action}
\step Open \textit{js/RenderMesh.js}
\step In the function \textit{RenderMesh(filename)}, look for \textit{object.scale  = new THREE.Vector(xDimension, yDimension, zDimension)} and change to the preferred dimensions.\end{steps}

\subsection{Results}
\label{subsec:results}
Figure 2 contains 
\section{Point-Plane Projection Approach}\
\label{sec:pointplaneprojectionapproach}
\subsection{Algorithm Overview}
\label{subsec:algorithmoverview}
In the algorithm used, the positions of a predefined volume of evenly spaced points are checked against the planes defined by the triangles in a triangle mesh imported from a Wavefront OBJ file. Points are projected onto these planes, which are then checked to see if they lie within the points that define the triangle itself \cite{wolfram}. If the projected points are within the triangle, the distance between the original point and projected point is checked to verify that the distance is within a tolerance defined by the spacing of the original set of points. If the distance falls within the tolerance, than the position of the point is kept to be exported.
\subsection{Implementation}
\label{subsec:implementation}
This approach was implemented in C++, using the TinyOBJLoader library for mesh importing, and the GLM library for vector types and math\cite{TinyObjLoader2015, GLM2015}. The program's procedure goes as follow:

\begin{steps}{Action}
\step Generate a volume of points of defined dimensions and density from which to subtract points.
\step Import the mesh and save the vertex list and index list.
\step Iterate through each point in the volume, and then through each triangle in the mesh, moving on to the next point when the current one is verified to either be within or outside of the tolerable range. To determine if a point is within the tolerable range the following calculations are made:
	\begin{enumerate}
  		\item Calculate the normal of the triangle in question
  		\item Find the central point of the triangle
  		\item Find the distance of this point from the origin of the coordinate grid
  		\item Project the point in question onto the plane defined by this information
  		\item Verify that the projected point lies within the legs of the triangle
  		\item Verify that the distance from the projected point to the original point is within tolerance 
	\end{enumerate}
\step Finally, if a point meets all of these conditions as it is being checked, it is pushed into a vector which is returned to the caller at the end of the iteration. This list of points is then written to a CSV file.
\end{steps}

\subsection{Tool Usage}
\label{subsec:toolusage}
The source for this tool can be found at \url{https://github.com/uwsbel/Mesh-to-pointcloud-tool}. TinyOBJLoader is already included in the source, meaning GLM is the only library you need to acquire. The only source files that need to be built are \textit{main.cpp’} and \textit{tiny\_obj\_loader.cc}. These should be compiled with threading and at least SSE2 enabled. To create a point cloud of an OBJ, run the executable and answer the prompts
\begin{steps}{Action}
\step Enter the path to the OBJ file
\step Enter the spacing desired between each point
\step Enter the desired side length of the volume of points to check against
\step Enter the amount of threads you want this to run on
\end{steps}

\subsection{Results}
\label{subsec:results}
Figure \ref{fig:pointplaneprojectionresults} contains different point clouds that were created with this tool. 
\begin{figure}[htp]
\centering
	\includegraphics[scale=0.5]{figures/figure_PointPlaneProjectionResults.png}
	\caption{Resulting point clouds from different mesh inputs using the Point-Plane Projection Approach.}
	\label{fig: pointplaneprojectionresults}
\end{figure}

\section{Salome Approach}\
\label{sec:salomeapproach}
Another approach to solve the problem is to use the existing tools/applications whose goal can be modified in order for us to create a point cloud. One of these techniques is to use CFD pre-processor applications which can be used to create structured/unstructured mesh. Assuming that a CFD mesh of a geometry is available, one can use the information of cells which have been created in the application and use the information of nodes data of the mesh and use the resulting points as a point cloud. In this technical report, Salome \cite{salome} is used in order to show this technique. It is worth mentioning that other pre-processor open source applications such as Gmesh \cite{gmesh} can be used in a similar manner.
\subsection{Algorithm Overview}
\label{subsec:algorithmoverview}
In order for Salome to create a mesh, either a geometry of interest should be imported in the program or the geometry should be created inside the geometry module of the Salome. For simple geometries, using the native geometry manipulation of Salome should solve the problem, although for more complex geometries one might need to consider creating the geometry in a CAD generator software such as SolidWorks \cite{solidworks} and save the file as a .step and import the resulting file in Salome.

Either way when the geometry is created, the mesh module inside Salome can be used in order to create a mesh. Different approaches can be chosen for the choice of meshing technique depending on the requirements of the point cloud. Finally, when the meshing is done, the file can be exported in a DAT format.


\subsection{Tool Usage}
\label{subsec:toolusage}
In this tutorial a simple geometry is created in Salome in the first step. For this purpose, geometry modules is selected as shown in the following figure.

\begin{steps}{Action}
\step Select the geometry module as shown in figure \ref{fig: salome1}.
\step A new entity can be created by selecting: New Entity\textrightarrow Primitives\textrightarrow Torus. 
\step Select the mesh module as shown in figure \ref{fig: salome2}.
\step Create a new mesh by selecting: Mesh\textrightarrow Create Mesh.
\step In the tree menu right clicking on the Mesh\_1 and selecting the Edit Mesh/Sub-mesh the spacing of the point cloud can be changed. Figures \ref{fig: salome3} show the simplest algorithm to create the point cloud. 
\end{steps}

\begin{figure}[htp]
\centering
	\includegraphics[scale=0.5]{figures/figure_salome1.png}
	\caption{Salome's toolbar when selecting the geometry module}
	\label{fig: salome1}
\end{figure}

\begin{figure}[htp]
\centering
	\includegraphics[scale=0.5]{figures/figure_salome2.png}
	\caption{Salome's toolbar when selecting the mesh module}
	\label{fig: salome2}
\end{figure}

\begin{figure}[htp]
\centering
	\includegraphics[scale=0.5]{figures/figure_salome3.png}
	\caption{Salome's toolbar when selecting the mesh module}
	\label{fig: salome3}
\end{figure}



\subsection{Results}
\label{subsec:results}
Figure \ref{fig: salome6} shows how a torus point cloud was created using Salome.
\begin{figure}[htp]
\centering
	\includegraphics[scale=0.5]{figures/figure_salome6.png}
	\caption{Mesh to Point-Cloud stages.}
	\label{fig: salome6}
\end{figure}


\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}          


